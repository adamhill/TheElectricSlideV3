import Foundation

// MARK: - PostScript Formula Concordance for Log-Log Scales
//
// UNDERSTANDING LOG-LOG SCALES:
// Log-Log scales represent powers of e (Euler's number, e ≈ 2.71828...).
// They enable calculations of arbitrary powers and roots: x^y for any x and y.
//
// The key principle: On LL scales, numbers represent e^(something), and that "something"
// is what appears on the D scale. This creates a powerful relationship:
//   - Cursor to x on LL scale → read ln(x) on D scale
//   - Move D scale by factor y → x^y appears on LL scale
//
// POSITIVE vs NEGATIVE POWERS:
//   Positive LL scales (LL0, LL1, LL2, LL3): represent e^(+x) for x > 1
//   Negative LL scales (LL00, LL01, LL02, LL03): represent e^(-x) for x < 1
//   The negative scales are reciprocals: LL00 ↔ LL0, LL01 ↔ LL1, etc.
//
// SCALE HIERARCHY (powers of 10 relationship):
//   LL0:  e^0.001 to e^0.01   (1.001 to 1.010)     - 1000x multiplier
//   LL1:  e^0.01 to e^0.1     (1.010 to 1.105)     - 100x multiplier  
//   LL2:  e^0.1 to e^1        (1.105 to 2.72)      - 10x multiplier
//   LL3:  e^1 to e^10         (2.72 to 22,000)     - 1x multiplier
//
//   LL00: e^-0.001 to e^-0.01 (0.999 to 0.990)     - -1000x multiplier
//   LL01: e^-0.01 to e^-0.1   (0.990 to 0.905)     - -100x multiplier
//   LL02: e^-0.1 to e^-1      (0.905 to 0.368)     - -10x multiplier
//   LL03: e^-1 to e^-10       (0.368 to 0.00005)   - -1x multiplier
//
// POSTSCRIPT FORMULA PATTERNS:
//   {ln 1000 mul log}        → log₁₀(ln(x) × 1000)      [LL0]
//   {ln -1000 mul log}       → log₁₀(ln(x) × -1000)     [LL00]
//   {ln -100 mul log 2 div}  → log₁₀(ln(x) × -100) / 2  [LL02B - referenced to A/B]
//
// The "2 div" (.5 add) variations reference the scale to A/B scales instead of C/D.
//
// POSTSCRIPT REFERENCES (postscript-engine-for-sliderules.ps):
// Positive LL Scales:
//   - LL0 scale:  Line 905  - {ln 1000 mul log}
//   - LL1 scale:  Line 915  - {ln 100 mul log}
//   - LL2 scale:  Line 925  - {ln 10 mul log}
//   - LL3 scale:  Line 935  - {ln log}
//
// Negative LL Scales:
//   - LL00B scale: Line 717  - {ln -100 mul log 2 div .5 add} (Hemmi 266 variant)
//   - LL00 scale:  Line 730  - {ln -1000 mul log}
//   - LL01 scale:  Line 740  - {ln -100 mul log}
//   - LL02B scale: Line 758  - {ln -10 mul log 2 div} (referenced to A/B)
//   - LL02 scale:  Line 772  - {ln -10 mul log}
//   - LL03 scale:  Line 785  - {ln -1 mul log} or {ln log neg}
//   - H266LL03:    Line 750  - {10 -9 exp mul ln -.1 mul log 2 div} (specialized)

// MARK: - Positive Log-Log Scales
//
// These scales represent positive powers of e: e^x where x > 0
// Used for raising numbers > 1 to any power, or extracting roots

public enum TheLogLog_LogLadyScales {
    
    // MARK: - LL3 Scale (Base Scale)
    
    /// LL3 scale: Base log-log scale for e^x where 0 ≤ x ≤ ln(22,000)
    ///
    /// **Description:** Primary log-log scale representing e^x for large powers
    /// **Formula:** log₁₀(ln(x)) where x represents e^(D scale value)
    /// **Range:** 2.72 (e¹) to 22,026 (e¹⁰)
    /// **Used for:** arbitrary-powers, nth-roots, exponential-calculations, compound-interest
    ///
    /// **Physical Applications:**
    /// - Nuclear decay: Half-life calculations using exponential decay
    /// - Finance: Compound interest A = Pe^(rt)
    /// - Population growth: N(t) = N₀e^(kt)
    /// - RC circuits: Voltage decay V(t) = V₀e^(-t/RC)
    /// - Radioactive dating: Age determination from decay ratios
    /// - Chemical kinetics: Reaction rate equations
    ///
    /// **Example 1:** Calculate 8.87^3.48
    /// 1. Locate 8.87 on LL3 scale
    /// 2. Set left C index to cursor
    /// 3. Move cursor to 3.48 on C scale
    /// 4. Read 697 on LL3 scale
    /// 5. Demonstrates arbitrary power calculation
    ///
    /// **Example 2:** Calculate 5th root of 100 (100^0.2)
    /// 1. Locate 100 on LL3
    /// 2. Set right C index to cursor
    /// 3. Move cursor to 2 on C (for 1/5 = 0.2)
    /// 4. Read 2.51 on LL3
    /// 5. Shows root extraction using reciprocal powers
    ///
    /// **Example 3:** Compound interest: $1000 at 5% for 10 years
    /// 1. Calculate e^(0.05 × 10) = e^0.5
    /// 2. Find e^0.5 ≈ 1.65 on LL2 (using D scale = 0.5)
    /// 3. Multiply by principal: 1000 × 1.65 = $1650
    /// 4. Demonstrates exponential growth
    ///
    /// **POSTSCRIPT REFERENCES:** Line 935 in postscript-engine-for-sliderules.ps
    public static func ll3Scale(length: Distance = 250.0) -> ScaleDefinition {
        // Formula: log₁₀(ln(x))
        // This maps e^x to position on the scale
        let ll3Function = CustomFunction(
            name: "LL3-scale",
            transform: { value in
                log10(log(value))  // log₁₀(ln(x))
            },
            inverseTransform: { transformed in
                exp(pow(10, transformed))  // e^(10^t)
            }
        )
        
        return ScaleBuilder()
            .withName("LL3")
            .withFunction(ll3Function)
            .withRange(begin: 2.74, end: 22026.0)  // e¹ to e¹⁰
            .withLength(length)
            .withTickDirection(.up)
            .withSubsections([
                ScaleSubsection(startValue: 2.74, tickIntervals: [1.0, 0.5, 0.1, 0.05], labelLevels: [0]),
                ScaleSubsection(startValue: 10.0, tickIntervals: [10.0, 5.0, 1.0, 0.5], labelLevels: [0]),
                ScaleSubsection(startValue: 100.0, tickIntervals: [100.0, 50.0, 10.0, 5.0], labelLevels: [0]),
                ScaleSubsection(startValue: 1000.0, tickIntervals: [1000.0, 500.0, 100.0, 50.0], labelLevels: [0])
            ])
            .withLabelFormatter(StandardLabelFormatter.integer)
            .withConstants([
                ConstantMarker(
                    value: 2.71828,
                    label: "e",
                    font: .medium,
                    position: .top
                )
            ])
            .build()
    }
    
    // MARK: - LL2 Scale
    
    /// LL2 scale: Medium-range log-log scale for e^(x/10)
    ///
    /// **Description:** Medium-range log-log scale representing e^(x/10)
    /// **Formula:** log₁₀(ln(x) × 10) = log₁₀(ln(x)) + 1
    /// **Range:** 1.105 (e^0.1) to 2.72 (e¹)
    /// **Used for:** moderate-powers, fractional-exponents, population-models
    ///
    /// **Physical Applications:**
    /// - Biology: Population doubling time calculations
    /// - Pharmacology: Drug concentration decay over hours
    /// - Acoustics: Sound pressure level conversions
    /// - Finance: Daily/monthly compound interest
    /// - Engineering: Gradual decay processes
    ///
    /// **Example 1:** Calculate 1.9^2.5
    /// 1. Rewrite as (1.9^0.25)^10
    /// 2. Locate 1.9 on LL2
    /// 3. Set right C index to cursor
    /// 4. Move cursor to 2.5 on C
    /// 5. Read on LL2, then look up to LL3 for ×10 power
    /// 6. Result ≈ 4.97
    ///
    /// **Example 2:** Bacterial growth: Double every 20 minutes
    /// 1. After 2 hours (6 doublings): 2^6 = 64
    /// 2. Use LL2/LL3 relationship with D scale
    /// 3. Demonstrates biological exponential growth
    ///
    /// **POSTSCRIPT REFERENCES:** Line 925 in postscript-engine-for-sliderules.ps
    public static func ll2Scale(length: Distance = 250.0) -> ScaleDefinition {
        // Formula: log₁₀(ln(x) × 10)
        // The ×10 makes this scale represent e^(x/10)
        let ll2Function = CustomFunction(
            name: "LL2-scale",
            transform: { value in
                log10(log(value) * 10.0)
            },
            inverseTransform: { transformed in
                exp(pow(10, transformed) / 10.0)
            }
        )
        
        return ScaleBuilder()
            .withName("LL2")
            .withFunction(ll2Function)
            .withRange(begin: 1.105, end: 2.72)  // e^0.1 to e^1
            .withLength(length)
            .withTickDirection(.up)
            .withSubsections([
                ScaleSubsection(startValue: 1.105, tickIntervals: [0.1, 0.05, 0.01, 0.005], labelLevels: [0]),
                ScaleSubsection(startValue: 1.5, tickIntervals: [0.1, 0.05, 0.01, 0.005], labelLevels: [0]),
                ScaleSubsection(startValue: 2.0, tickIntervals: [0.1, 0.05, 0.01, 0.005], labelLevels: [0])
            ])
            .withLabelFormatter(StandardLabelFormatter.decimal(places: 2))
            .build()
    }
    
    // MARK: - LL1 Scale
    
    /// LL1 scale: Small-range log-log scale for e^(x/100)
    ///
    /// **Description:** Small-range log-log scale for values very close to 1
    /// **Formula:** log₁₀(ln(x) × 100) = log₁₀(ln(x)) + 2
    /// **Range:** 1.0101 (e^0.01) to 1.105 (e^0.1)
    /// **Used for:** small-powers, precision-calculations, near-unity-exponents
    ///
    /// **Physical Applications:**
    /// - Metrology: Small measurement corrections
    /// - Optics: Thin lens approximations
    /// - Economics: Small percentage changes
    /// - Quality control: Tolerance calculations
    /// - Surveying: Small angle corrections
    ///
    /// **Example:** Calculate 1.04^100
    /// 1. Locate 1.04 on LL1 scale
    /// 2. To raise to power 100, look "two scales up"
    /// 3. Read 50.5 on LL3 scale
    /// 4. Demonstrates power-of-10 scale jumping
    ///
    /// **POSTSCRIPT REFERENCES:** Line 915 in postscript-engine-for-sliderules.ps
    public static func ll1Scale(length: Distance = 250.0) -> ScaleDefinition {
        // Formula: log₁₀(ln(x) × 100)
        let ll1Function = CustomFunction(
            name: "LL1-scale",
            transform: { value in
                log10(log(value) * 100.0)
            },
            inverseTransform: { transformed in
                exp(pow(10, transformed) / 100.0)
            }
        )
        
        return ScaleBuilder()
            .withName("LL1")
            .withFunction(ll1Function)
            .withRange(begin: 1.0101, end: 1.105)  // e^0.01 to e^0.1
            .withLength(length)
            .withTickDirection(.up)
            .withSubsections([
                ScaleSubsection(startValue: 1.01, tickIntervals: [0.01, 0.005, 0.001, 0.0005], labelLevels: [0]),
                ScaleSubsection(startValue: 1.05, tickIntervals: [0.01, 0.005, 0.001, 0.0005], labelLevels: [0])
            ])
            .withLabelFormatter(StandardLabelFormatter.decimal(places: 3))
            .build()
    }
    
    // MARK: - LL0 Scale
    
    /// LL0 scale: Ultra-precision log-log scale for e^(x/1000)
    ///
    /// **Description:** Ultra-precision scale for values extremely close to 1
    /// **Formula:** log₁₀(ln(x) × 1000) = log₁₀(ln(x)) + 3
    /// **Range:** 1.001 (e^0.001) to 1.010 (e^0.01)
    /// **Used for:** high-precision-calculations, small-corrections, micro-adjustments
    ///
    /// **Physical Applications:**
    /// - Precision engineering: Thermal expansion coefficients
    /// - Calibration: Instrument correction factors
    /// - Materials science: Elastic modulus variations
    /// - Astronomy: Parallax corrections
    /// - Geodesy: Earth curvature corrections
    ///
    /// **Example:** Calculate 1.002^1000
    /// 1. Locate 1.002 on LL0 scale
    /// 2. To raise to power 1000, look "three scales up"
    /// 3. Read 7.4 on LL3 scale
    /// 4. Demonstrates the power of scale hierarchy
    ///
    /// **POSTSCRIPT REFERENCES:** Line 905 in postscript-engine-for-sliderules.ps
    public static func ll0Scale(length: Distance = 250.0) -> ScaleDefinition {
        // Formula: log₁₀(ln(x) × 1000)
        let ll0Function = CustomFunction(
            name: "LL0-scale",
            transform: { value in
                log10(log(value) * 1000.0)
            },
            inverseTransform: { transformed in
                exp(pow(10, transformed) / 1000.0)
            }
        )
        
        return ScaleBuilder()
            .withName("LL0")
            .withFunction(ll0Function)
            .withRange(begin: 1.001, end: 1.0101)  // e^0.001 to e^0.01
            .withLength(length)
            .withTickDirection(.up)
            .withSubsections([
                ScaleSubsection(startValue: 1.001, tickIntervals: [0.001, 0.0005, 0.0001, 0.00005], labelLevels: [0]),
                ScaleSubsection(startValue: 1.005, tickIntervals: [0.001, 0.0005, 0.0001, 0.00005], labelLevels: [0])
            ])
            .withLabelFormatter(StandardLabelFormatter.decimal(places: 4))
            .build()
    }
    
    // MARK: - Negative Log-Log Scales (Reciprocal)
    
    /// LL03 scale: Base reciprocal log-log scale for e^(-x)
    ///
    /// **Description:** Reciprocal of LL3, represents e^(-x) for negative powers
    /// **Formula:** log₁₀(-ln(x)) = log₁₀(ln(1/x))
    /// **Range:** 0.368 (e^-1) to 0.00005 (e^-10)
    /// **Used for:** reciprocal-powers, decay-processes, inverse-relationships
    ///
    /// **Physical Applications:**
    /// - Radioactive decay: Activity remaining after n half-lives
    /// - Electrical: Capacitor discharge V = V₀e^(-t/RC)
    /// - Pharmacology: Drug elimination from bloodstream
    /// - Heat transfer: Cooling curves (Newton's law)
    /// - Optics: Light absorption (Beer's law)
    ///
    /// **Example 1:** Calculate 0.75^10
    /// 1. Locate 0.75 on LL02 scale (e^-0.3 range)
    /// 2. Set left C index to cursor
    /// 3. Move cursor to 1 (for power 10, look up scale)
    /// 4. Read 0.056 on LL03
    /// 5. Demonstrates decay/damping calculations
    ///
    /// **Example 2:** RC circuit: Find voltage after 5τ
    /// 1. V(t) = V₀e^(-t/τ), after 5τ: V = V₀e^-5
    /// 2. Locate e^-5 ≈ 0.0067 on LL03
    /// 3. About 0.67% of initial voltage remains
    /// 4. Critical for electronics timing
    ///
    /// **POSTSCRIPT REFERENCES:** Line 785 in postscript-engine-for-sliderules.ps
    public static func ll03Scale(length: Distance = 250.0) -> ScaleDefinition {
        // Formula: log₁₀(-ln(x)) = log₁₀(ln(1/x))
        // For x < 1, this gives positive values
        let ll03Function = CustomFunction(
            name: "LL03-scale",
            transform: { value in
                log10(-log(value))  // log₁₀(-ln(x))
            },
            inverseTransform: { transformed in
                exp(-pow(10, transformed))  // e^(-10^t)
            }
        )
        
        return ScaleBuilder()
            .withName("LL03")
            .withFunction(ll03Function)
            .withRange(begin: 0.00005, end: 0.368)  // e^-10 to e^-1
            .withLength(length)
            .withTickDirection(.up)
            .withSubsections([
                ScaleSubsection(startValue: 0.00005, tickIntervals: [0.0001, 0.00005, 0.00001, 0.000005], labelLevels: [0]),
                ScaleSubsection(startValue: 0.0001, tickIntervals: [0.0001, 0.00005, 0.00001, 0.000005], labelLevels: [0]),
                ScaleSubsection(startValue: 0.001, tickIntervals: [0.001, 0.0005, 0.0001, 0.00005], labelLevels: [0]),
                ScaleSubsection(startValue: 0.01, tickIntervals: [0.01, 0.005, 0.001, 0.0005], labelLevels: [0]),
                ScaleSubsection(startValue: 0.1, tickIntervals: [0.1, 0.05, 0.01, 0.005], labelLevels: [0])
            ])
            .withLabelFormatter(StandardLabelFormatter.decimal(places: 4))
            .withLabelColor((red: 1.0, green: 0.0, blue: 0.0))  // Red labels
            .withConstants([
                ConstantMarker(
                    value: 0.36788,  // 1/e
                    label: "1/e",
                    font: .small,
                    position: .top
                )
            ])
            .build()
    }
    
    // MARK: - LL02 Scale
    
    /// LL02 scale: Medium reciprocal log-log scale for e^(-x/10)
    ///
    /// **Description:** Reciprocal of LL2, medium-range negative powers
    /// **Formula:** log₁₀(-ln(x) × 10)
    /// **Range:** 0.368 (e^-1) to 0.905 (e^-0.1)
    /// **Used for:** moderate-decay, damping-calculations, attenuation
    ///
    /// **Physical Applications:**
    /// - Acoustics: Sound attenuation through materials
    /// - Optics: Filter transmission coefficients
    /// - Mechanical: Damped oscillations
    /// - Economics: Depreciation curves
    /// - Communications: Signal loss in transmission lines
    ///
    /// **Example:** Calculate 0.78^3.4
    /// 1. Locate 0.78 on LL02 scale
    /// 2. Set left C index to cursor
    /// 3. Move cursor to 3.4 on C
    /// 4. Read 0.43 on LL02
    /// 5. Demonstrates fractional negative powers
    ///
    /// **POSTSCRIPT REFERENCES:** Line 772 in postscript-engine-for-sliderules.ps
    public static func ll02Scale(length: Distance = 250.0) -> ScaleDefinition {
        // Formula: log₁₀(-ln(x) × 10)
        let ll02Function = CustomFunction(
            name: "LL02-scale",
            transform: { value in
                log10(-log(value) * 10.0)
            },
            inverseTransform: { transformed in
                exp(-pow(10, transformed) / 10.0)
            }
        )
        
        return ScaleBuilder()
            .withName("LL02")
            .withFunction(ll02Function)
            .withRange(begin: 0.368, end: 0.905)  // e^-1 to e^-0.1
            .withLength(length)
            .withTickDirection(.up)
            .withSubsections([
                ScaleSubsection(startValue: 0.37, tickIntervals: [0.05, 0.02, 0.01, 0.005], labelLevels: [0]),
                ScaleSubsection(startValue: 0.50, tickIntervals: [0.05, 0.02, 0.01, 0.005], labelLevels: [0]),
                ScaleSubsection(startValue: 0.80, tickIntervals: [0.02, 0.01, 0.005, 0.001], labelLevels: [0])
            ])
            .withLabelFormatter(StandardLabelFormatter.decimal(places: 3))
            .withLabelColor((red: 1.0, green: 0.0, blue: 0.0))  // Red labels
            .withConstants([
                ConstantMarker(
                    value: 0.36788,  // 1/e at left edge
                    label: "1/e",
                    font: .small,
                    position: .top
                )
            ])
            .build()
    }
    
    // MARK: - LL01 Scale
    
    /// LL01 scale: Small reciprocal log-log scale for e^(-x/100)
    ///
    /// **Description:** Reciprocal of LL1, small negative powers
    /// **Formula:** log₁₀(-ln(x) × 100)
    /// **Range:** 0.905 (e^-0.1) to 0.990 (e^-0.01)
    /// **Used for:** small-decay, precision-attenuation, quality-factors
    ///
    /// **Physical Applications:**
    /// - Materials: Low-loss dielectrics
    /// - Optics: High-transmission filters
    /// - RF engineering: Cable loss calculations
    /// - Precision: Small correction factors
    ///
    /// **Example:** Calculate 0.99^560
    /// 1. Rewrite as (0.99^5.6)^100
    /// 2. Locate 0.99 on LL01
    /// 3. Use C scale for power 5.6
    /// 4. Look "two scales down" to LL03
    /// 5. Read 0.0036
    ///
    /// **POSTSCRIPT REFERENCES:** Line 740 in postscript-engine-for-sliderules.ps
    public static func ll01Scale(length: Distance = 250.0) -> ScaleDefinition {
        // Formula: log₁₀(-ln(x) × 100)
        let ll01Function = CustomFunction(
            name: "LL01-scale",
            transform: { value in
                log10(-log(value) * 100.0)
            },
            inverseTransform: { transformed in
                exp(-pow(10, transformed) / 100.0)
            }
        )
        
        return ScaleBuilder()
            .withName("LL01")
            .withFunction(ll01Function)
            .withRange(begin: 0.905, end: 0.990)  // e^-0.1 to e^-0.01
            .withLength(length)
            .withTickDirection(.up)
            .withSubsections([
                ScaleSubsection(startValue: 0.90, tickIntervals: [0.01, 0.005, 0.001, 0.0005], labelLevels: [0]),
                ScaleSubsection(startValue: 0.95, tickIntervals: [0.01, 0.005, 0.001, 0.0005], labelLevels: [0]),
                ScaleSubsection(startValue: 0.98, tickIntervals: [0.005, 0.001, 0.0005, 0.0001], labelLevels: [0])
            ])
            .withLabelFormatter(StandardLabelFormatter.decimal(places: 3))
            .withLabelColor((red: 1.0, green: 0.0, blue: 0.0))  // Red labels
            .build()
    }
    
    // MARK: - LL00 Scale
    
    /// LL00 scale: Ultra-precision reciprocal log-log scale for e^(-x/1000)
    ///
    /// **Description:** Reciprocal of LL0, ultra-precision negative powers
    /// **Formula:** log₁₀(-ln(x) × 1000)
    /// **Range:** 0.990 (e^-0.01) to 0.999 (e^-0.001)
    /// **Used for:** ultra-precision-decay, micro-corrections, quality-factors
    ///
    /// **Physical Applications:**
    /// - High-Q resonators: Quality factor calculations
    /// - Precision optics: Anti-reflection coating optimization
    /// - Materials science: Ultra-low-loss materials
    /// - Metrology: High-precision calibrations
    ///
    /// **POSTSCRIPT REFERENCES:** Line 730 in postscript-engine-for-sliderules.ps
    public static func ll00Scale(length: Distance = 250.0) -> ScaleDefinition {
        // Formula: log₁₀(-ln(x) × 1000)
        let ll00Function = CustomFunction(
            name: "LL00-scale",
            transform: { value in
                log10(-log(value) * 1000.0)
            },
            inverseTransform: { transformed in
                exp(-pow(10, transformed) / 1000.0)
            }
        )
        
        return ScaleBuilder()
            .withName("LL00")
            .withFunction(ll00Function)
            .withRange(begin: 0.990, end: 0.999)  // e^-0.01 to e^-0.001
            .withLength(length)
            .withTickDirection(.up)
            .withSubsections([
                ScaleSubsection(startValue: 0.990, tickIntervals: [0.001, 0.0005, 0.0001, 0.00005], labelLevels: [0]),
                ScaleSubsection(startValue: 0.995, tickIntervals: [0.001, 0.0005, 0.0001, 0.00002], labelLevels: [0]),
                ScaleSubsection(startValue: 0.998, tickIntervals: [0.0005, 0.0001, 0.00005, 0.00001], labelLevels: [0])
            ])
            .withLabelFormatter(StandardLabelFormatter.decimal(places: 4))
            .withLabelColor((red: 1.0, green: 0.0, blue: 0.0))  // Red labels
            .build()
    }
    
    // MARK: - Special Variant Scales
    
    /// LL02B scale: Combined LL02/LL03 scale referenced to A/B scales
    ///
    /// **Description:** Extended negative scale referenced to A/B (square) scales
    /// **Formula:** log₁₀(-ln(x) × 10) / 2 (half-length compression)
    /// **Range:** 0.00005 (e^-10) to 0.904 (e^-0.1)
    /// **Used for:** square-root-relationships, combined-calculations, space-saving
    ///
    /// **Physical Applications:**
    /// - Combines functionality of LL02 and LL03 in one scale
    /// - Space-efficient slide rule designs (Hemmi 266)
    /// - Allows direct reading with A/B scales
    /// - Used in compact professional rules
    ///
    /// **Note:** This scale compresses two decades into the space of one by
    /// referencing to A/B scales (which are themselves compressed by factor of 2)
    ///
    /// **POSTSCRIPT REFERENCES:** Line 758 in postscript-engine-for-sliderules.ps
    public static func ll02BScale(length: Distance = 250.0) -> ScaleDefinition {
        // Formula: log₁₀(-ln(x) × 10) / 2
        // The "/ 2" references this to A/B scales
        let ll02BFunction = CustomFunction(
            name: "LL02B-scale",
            transform: { value in
                log10(-log(value) * 10.0) / 2.0
            },
            inverseTransform: { transformed in
                exp(-pow(10, transformed * 2.0) / 10.0)
            }
        )
        
        return ScaleBuilder()
            .withName("LL02B")
            .withFunction(ll02BFunction)
            .withRange(begin: 0.00005, end: 0.904)  // Extended range
            .withLength(length)
            .withTickDirection(.up)
            .withSubsections([
                ScaleSubsection(startValue: 0.00005, tickIntervals: [0.0001, 0.00005, 0.00001], labelLevels: [0]),
                ScaleSubsection(startValue: 0.0001, tickIntervals: [0.0001, 0.00005], labelLevels: [0]),
                ScaleSubsection(startValue: 0.0010, tickIntervals: [0.005, 0.001, 0.0005], labelLevels: [0]),
                ScaleSubsection(startValue: 0.01, tickIntervals: [0.01, 0.005, 0.001], labelLevels: [0]),
                ScaleSubsection(startValue: 0.10, tickIntervals: [0.1, 0.05, 0.01, 0.005], labelLevels: [0]),
                ScaleSubsection(startValue: 0.80, tickIntervals: [0.05, 0.01, 0.002], labelLevels: [0])
            ])
            .withLabelFormatter(StandardLabelFormatter.decimal(places: 4))
            .withLabelColor((red: 1.0, green: 0.0, blue: 0.0))  // Red labels
            .build()
    }
    
    /// LL00B scale (Hemmi 266): Variant of LL00 referenced to A/B scales
    ///
    /// **Description:** Ultra-precision reciprocal scale with A/B reference
    /// **Formula:** log₁₀(-ln(x) × 100) / 2 + 0.5
    /// **Range:** 0.900 (e^-0.105) to 0.999 (e^-0.001)
    /// **Used for:** compact-designs, combined-operations, Hemmi-266-compatibility
    ///
    /// **Note:** The "+0.5" offset aligns this with the A/B scale positioning.
    /// This is a specialized variant found on the Hemmi 266 series.
    ///
    /// **POSTSCRIPT REFERENCES:** Line 717 in postscript-engine-for-sliderules.ps
    public static func ll00BScale(length: Distance = 250.0) -> ScaleDefinition {
        // Formula: log₁₀(-ln(x) × 100) / 2 + 0.5
        let ll00BFunction = CustomFunction(
            name: "LL00B-scale",
            transform: { value in
                log10(-log(value) * 100.0) / 2.0 + 0.5
            },
            inverseTransform: { transformed in
                exp(-pow(10, (transformed - 0.5) * 2.0) / 100.0)
            }
        )
        
        return ScaleBuilder()
            .withName("LL00B")
            .withFunction(ll00BFunction)
            .withRange(begin: 0.900, end: 0.999)
            .withLength(length)
            .withTickDirection(.up)
            .withSubsections([
                ScaleSubsection(startValue: 0.900, tickIntervals: [0.05, 0.01, 0.005, 0.001], labelLevels: [0]),
                ScaleSubsection(startValue: 0.950, tickIntervals: [0.01, 0.005, 0.001, 0.0005], labelLevels: [0]),
                ScaleSubsection(startValue: 0.980, tickIntervals: [0.01, 0.005, 0.001, 0.0002], labelLevels: [0]),
                ScaleSubsection(startValue: 0.990, tickIntervals: [0.005, 0.001, 0.0005, 0.0001], labelLevels: [0]),
                ScaleSubsection(startValue: 0.995, tickIntervals: [0.001, 0.0005, 0.0001, 0.00005], labelLevels: [0]),
                ScaleSubsection(startValue: 0.998, tickIntervals: [0.0005, 0.0001, 0.00002], labelLevels: [0])
            ])
            .withLabelFormatter(StandardLabelFormatter.decimal(places: 3))
            .withLabelColor((red: 1.0, green: 0.0, blue: 0.0))  // Red labels
            .build()
    }
    
    /// H266LL01 scale: Hemmi 266 variant of LL01 (subset of LL00B)
    ///
    /// **Description:** Subset of LL00B scale used in Hemmi 266 design
    /// **Formula:** Same as LL00B: log₁₀(-ln(x) × 100) / 2 + 0.5
    /// **Range:** 0.90 to 0.99 (truncated from LL00B)
    /// **Used for:** Hemmi-266-specific-layouts, space-optimization
    ///
    /// **Note:** This is essentially LL00B with a truncated range, used
    /// in the Hemmi 266 to create a more compact scale arrangement.
    ///
    /// **POSTSCRIPT REFERENCES:** Line 725 in postscript-engine-for-sliderules.ps
    public static func h266LL01Scale(length: Distance = 250.0) -> ScaleDefinition {
        // This uses the same function as LL00B but with different range
        let ll00BScale = ll00BScale(length: length)
        
        return ScaleDefinition(
            name: "H266LL01",
            function: ll00BScale.function,
            beginValue: 0.90,  // Truncated range
            endValue: 0.99,
            scaleLengthInPoints: length,
            layout: ll00BScale.layout,
            tickDirection: ll00BScale.tickDirection,
            subsections: [
                ScaleSubsection(startValue: 0.900, tickIntervals: [0.05, 0.01, 0.005, 0.001], labelLevels: [0]),
                ScaleSubsection(startValue: 0.950, tickIntervals: [0.01, 0.005, 0.001, 0.0005], labelLevels: [0]),
                ScaleSubsection(startValue: 0.980, tickIntervals: [0.01, 0.005, 0.001, 0.0002], labelLevels: [0])
            ],
            defaultTickStyles: ll00BScale.defaultTickStyles,
            labelFormatter: ll00BScale.labelFormatter,
            labelColor: (red: 1.0, green: 0.0, blue: 0.0),  // Red labels
            constants: []
        )
    }
    
    /// H266LL03 scale: Specialized ultra-small negative power scale
    ///
    /// **Description:** Specialized scale for extremely small values (10^-9 × x range)
    /// **Formula:** log₁₀(ln(x × 10^-9) × -0.1) / 2
    /// **Range:** 1 to 50,000 (representing 10^-9 to 5×10^-5)
    /// **Used for:** nano-scale-calculations, quantum-effects, ultra-precision-work
    ///
    /// **Physical Applications:**
    /// - Nanotechnology: Molecular-scale measurements
    /// - Quantum physics: Probability amplitudes
    /// - Semiconductor: Gate oxide thickness calculations
    /// - Precision metrology: Atomic-scale measurements
    /// - Materials science: Thin film properties
    ///
    /// **Formula Breakdown:**
    /// For input value n (1 to 50,000):
    ///   x = n × 10^-9 (actual represented value)
    ///   transform = log₁₀(ln(x) × -0.1) / 2
    ///   
    /// This creates a scale where:
    ///   - 1 represents 10^-9
    ///   - 10 represents 10^-8
    ///   - 100 represents 10^-7
    ///   - 50,000 represents 5×10^-5
    ///
    /// **Label Format:** Labels show as "10^-X" notation
    /// Example: value 1 → "10^-9", value 100 → "10^-7"
    ///
    /// **Example:** Ultra-thin film calculation
    /// 1. Film thickness = 10 nm = 10^-8 m
    /// 2. Locate 10 on H266LL03 scale
    /// 3. Use with other scales for area/volume calculations
    /// 4. Critical for semiconductor manufacturing
    ///
    /// **POSTSCRIPT REFERENCES:** Line 750 in postscript-engine-for-sliderules.ps
    /// PostScript formula: {10 -9 exp mul ln -.1 mul log 2 div}
    public static func h266LL03Scale(length: Distance = 250.0) -> ScaleDefinition {
        // Formula: log₁₀(ln(x × 10^-9) × -0.1) / 2
        // This handles ultra-small values in the 10^-9 range
        let h266LL03Function = CustomFunction(
            name: "H266LL03-scale",
            transform: { value in
                // value represents the scale reading (1 to 50,000)
                // actual physical value is value × 10^-9
                let actualValue = value * 1e-9
                return log10(log(actualValue) * -0.1) / 2.0
            },
            inverseTransform: { transformed in
                // Reverse: from position to scale reading
                let lnValue = pow(10, transformed * 2.0) / -0.1
                let actualValue = exp(lnValue)
                return actualValue / 1e-9  // Convert back to scale units
            }
        )
        
        // Special label formatter for 10^-X notation
        let h266Formatter: LabelFormatter = { value in
            // Calculate the exponent: log₁₀(value × 10^-9)
            let exponent = log10(value * 1e-9)
            let roundedExp = Int(round(exponent))
            
            // Format as "10^-X" but suppress some labels for clarity
            if value < 2 || (value >= 10 && value.truncatingRemainder(dividingBy: 10) == 0) {
                return String(format: "10⁻%d", abs(roundedExp))
            }
            return nil  // Suppress intermediate labels
        }
        
        return ScaleBuilder()
            .withName("H266LL03")
            .withFunction(h266LL03Function)
            .withRange(begin: 1.0, end: 50000.0)  // Scale units, not physical values
            .withLength(length)
            .withTickDirection(.up)
            .withSubsections([
                ScaleSubsection(startValue: 1.0, tickIntervals: [1.0], labelLevels: [0]),
                ScaleSubsection(startValue: 2.0, tickIntervals: [10.0, 5.0, 1.0], labelLevels: [0]),
                ScaleSubsection(startValue: 10.0, tickIntervals: [10.0, 5.0], labelLevels: [0]),
                ScaleSubsection(startValue: 20.0, tickIntervals: [100.0, 50.0, 10.0], labelLevels: [0]),
                ScaleSubsection(startValue: 100.0, tickIntervals: [100.0, 500.0, 100.0], labelLevels: [0]),
                ScaleSubsection(startValue: 200.0, tickIntervals: [1000.0, 500.0, 100.0], labelLevels: [0]),
                ScaleSubsection(startValue: 1000.0, tickIntervals: [1000.0, 5000.0, 1000.0], labelLevels: [0]),
                ScaleSubsection(startValue: 2000.0, tickIntervals: [10000.0, 5000.0, 1000.0], labelLevels: [0]),
                ScaleSubsection(startValue: 10000.0, tickIntervals: [10000.0, 50000.0, 10000.0], labelLevels: [0]),
                ScaleSubsection(startValue: 20000.0, tickIntervals: [100000.0, 50000.0, 10000.0], labelLevels: [0])
            ])
            .withLabelFormatter(h266Formatter)
            .withLabelColor((red: 1.0, green: 0.0, blue: 0.0))  // Red labels
            .build()
    }
}

// MARK: - Usage Examples and Relationships

extension TheLogLogScales {
    
    /// Examples demonstrating log-log scale relationships and calculations
    public static func examples() {
        print("=== Log-Log Scale Examples ===\n")
        
        // Example 1: Scale hierarchy (powers of 10)
        print("Example 1: Powers of 10 relationship")
        print("If D scale = 2, then:")
        print("  LL3 = e² ≈ 7.39")
        print("  LL2 = e^0.2 ≈ 1.22")
        print("  LL1 = e^0.02 ≈ 1.020")
        print("  LL0 = e^0.002 ≈ 1.002")
        print()
        
        // Example 2: Reciprocal relationship
        print("Example 2: Reciprocal relationship")
        print("Any value on LL scale has reciprocal on LL0X scale:")
        print("  LL3: 7.39 ↔ LL03: 0.135 (1/7.39)")
        print("  LL2: 1.22 ↔ LL02: 0.819 (1/1.22)")
        print()
        
        // Example 3: Apollo moon missions
        print("Example 3: Historical - Apollo Program")
        print("Astronauts used Pickett N600-ES with LL scales for:")
        print("  - Fuel consumption: exponential burn calculations")
        print("  - Trajectory: e^x growth/decay for orbital mechanics")
        print("  - Life support: O₂ consumption over mission duration")
        print()
    }
}

